python优雅自由的编程风格，让人爱不释手。而他优雅的背后，则是其对内存的合理设计。
python的内存管理主要使用了3种机制

一： 引用计数

python是一种动态类型， 所以需要引用计数，动态类型: 不使用显示数据类型来声明变量，且确定一个变量的类型 是在第一次给它赋值的时候确认的

引用计数: 
统计了有哪些变量引用 指向了当前对象，		
Python内部使用引用计数，来保持追踪内存中的对象，所有对象都有引用计数。
当有新的引用指向变量，引用计数+1
当有无效的引用发生的时候，引用计数-1
当对象的引用计数为0的时候，它将被垃圾回收机制销毁掉

sys.getrefcount() 可以查看引用计数

引用计数增加
1.对象被创建：a="cc"
2 对象被引用：b=a
3 被作为参数传递给函数：func(a)
4 作为容器对象的一个元素：li =["ff",a]

引用计数减少
1 对象的别名被显式的销毁：del x 
2 对象的别名被重新赋值 a = "bb"
3 对象离开作用域
def func():
  a = "cc"
func()

二：垃圾回收
垃圾回收的作用(gc机制): garbage collection
当一个对象的引用计数归零时，它将被垃圾回收机制处理掉。
当然除了引用计数为0的会被清除，还有一种情况也会被垃圾收集器清掉：当两个对象相互引用时，他们本身其他的引用已经为0了(a引用b, b引用a, 导致其引用计数永远不为0)
这是因为垃圾回收机制还有一个循环垃圾回收器, 确保释放循环引用对象。

什么时候会垃圾回收？
1 程序退出时 
2 GC达到阀值时
python在运行时， 记录其中分配对象和取消分配对象的次数，当两者的差值高于某个阀值时，垃圾回收才会启动
>>> gc.get_threshold()
(700, 10, 10)
3 手动调用gc.collect()


三 内存池机制
python又分为大内存和小内存。大小以256字节为界限，对于大内存使用Malloc进行分配，而对于小内存则使用内存池进行分配。
许多时候，python中的对象，所需要使用的内存，都是比较小的，而且申请、释放是比较频繁的。如果采用直接向操作系统malloc申请、free释放的方式，频发操作，必然影响python的性能。而引入内存池技术，就可以有效解决这个问题。

python的内存池是一个缓存区，用于管理小于256个字节的对象的内存分配，主要用于管理小块内存对象，比如整型数值、字符串、元组等

当程序需要创建这些小块对象时，Python会从内存池中分配一段内存空间，并将其划分为多个大小相等的块，保存在内存池中

当程序需要销毁这些对象时，Python会将它们标记为未使用状态，并不会立即释放内存，而是保留在内存池以备再次使用，避免了频繁的内存分配和释放操作。

